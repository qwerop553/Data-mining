teens <- read.csv("C:/data_mining/k_means/snsdata.csv")
str(teens)
table(teens$gender)
table(teens$gender, useNA='ifany') # NA 도 집계
summary(teens$age) # summary는 원래 집계
teens$gender <- ifelse(is.na(teens$gender), "0", teens$gender)
teens$gender <- factor(teens$gender, levels = c("0", "1", "2"), labels = c("NA", "F", "M"))
teens$female <- ifelse(teens$gender == "F", 1, 0)
teens$male <- ifelse(teens$gender == "M", 1, 0)
teens$no_gender <- ifelse(teens$gender == "NA", 1, 0)
# 확인
table(teens$female);table(teens$male);table(teens$no_gender);
# SNS를 이용한 십대 시장 세분화
# 십대 SNS 페이지의 텍스트를 이요하여 스포츠, 종교, 음악과 같은 공통 관심을 공유하는 그룹을 찾을 수 있음
# 데이터 수집: 데이터는 SNS 사이트를 크롤링해서 가져옴
# 데이터 탐색 및 준비
library(ggplot2)
library(tidyverse)
teens <- read.csv("C:/data_mining/k_means/snsdata.csv")
str(teens)
table(teens$gender)
table(teens$gender, useNA='ifany') # NA 도 집계
summary(teens$age) # summary는 원래 집계
teens$age <- ifelse(teens$age >= 13 &teens$age < 20, teens$age, NA)
summary(teens$age)
# 확인
table(teens$female);table(teens$male);table(teens$no_gender);
teens$female <- ifelse(!is.na(teens$gender) & teens$gender == "F", 1, 0)
teens$male <- ifelse(!is.na(teens$gender) & teens$gender == "M", 1, 0)
teens$no_gender <- ifelse(is.na(teens$gender), 1, 0)
# 확인
table(teens$female);table(teens$male);table(teens$no_gender);
2724 + 5222 == 7946
# 연령의 평균, 17.25243 세
mean(teens$age, na.rm = T)
# 성별의 분포
g <- ggplot(teens, aes(age))
g + geom_density(aes(fill=gender), color=NA, width = 0.5, alpha=0.3)
teens$age_fl <- floor(teens$age)
table(teens$age_fl, teens$gender)
table(teens$age_fl, teens$gender, useNA='ifany')
# 졸업 연도별 평균나이
teens %>% group_by(gradyear) %>% summarize(me=mean(age, na.rm=T))
# 졸업 연도별 평균나이
teens %>% group_by(gradyear) %>% summarize(me=mean(age, na.rm=T))
aggregate(age~gradyear, teens, FUN = function(x) mean(x, na.rm=T))
aggregate(age~gradyear, teens, mean, na.rm=T)
aggregate(age~gradyear, teens, mean)
# 졸업 연도의 결측치 확인
table(teens$gradyear, useNA='ifany') # 없음
# 졸업 연도별 평균나이
teens %>% group_by(gradyear) %>% summarize(me=mean(age, na.rm=T))
aggregate(age~gradyear, teens, FUN = function(x) mean(x, na.rm=T))
aggregate(age~gradyear, teens, mean, na.rm=T)
aggregate(age~gradyear, teens, mean)
# 졸업 연도별 평균나이
teens %>% group_by(gradyear) %>% summarize(me=mean(age, na.rm=T), sd=sd(age, na.rm=T))
aggregate(age~gradyear, teens, FUN = function(x) c(mean(x, na.rm=T), sd(age, na.rm=T))
aggregate(age~gradyear, teens, FUN = function(x) c(mean(x, na.rm=T), sd(age, na.rm=T)))
aggregate(age~gradyear, teens, FUN = function(x) c(mean(x, na.rm=T), sd(age, na.rm=T)))
aggregate(age~gradyear, teens, FUN = function(x) c(mean(x, na.rm=T), sd(na.rm=T)))
aggregate(age~gradyear, teens, FUN = function(x) c(mean(x, na.rm=T), sd(x, na.rm=T)))
aggregate(age~gradyear, teens, mean, sd, na.rm=T)
aggregate(age~gradyear, teens, c(mean, sd), na.rm=T)
aggregate(age~gradyear, teens, c(mean, sd), na.rm=T)
aggregate(age~gradyear, teens, mean, sd)
aggregate(age~gradyear, teens, c(mean, sd))
aggregate(age~gradyear, teens, mean, na.rm=T)
aggregate(age~gradyear, teens, mean)
# 연령 결측치 처리코드
table(teens$age, useNA='ifany')
ave_age <- ave(teens$age, teens$gradyear, FUN=function(x) mean(x, na.rm = TRUE))
# mean의 옵션을 주기 위해 FUN 인자로 mean을 전달
table(ave_age) #넣기 전에 확인
teens$age <- ifelse(is.na(teens$age), ave_age, teens$age)
interests <- teens[5:40]
teens
?scale
teen_clusters
interests_z <- as.data.frame(lapply(interests, scale)) # 표준정규분포화 시켜준다
interests_z
set.seed(1234)
teen_clusters <- kmeans(interests_z, 5)
teen_clusters
teen_clusters$size
teen_clusters$centers
# 처음 5개의 데이터만 살펴보기
teens[1:5, c("cluster", "gender", "age", "friends")]
# 처음 5개의 데이터만 살펴보기
teens[1:5, c("cluster", "gender", "age", "friends")]
# 처음 5개의 데이터만 살펴보기
teens[1:5, c("clusters", "gender", "age", "friends")]
# 처음 5개의 데이터만 살펴보기
teens[1:5, c("cluster", "gender", "age", "friends")]
teens$cluster <- teen_clusters$cluster
# 처음 5개의 데이터만 살펴보기
teens[1:5, c("cluster", "gender", "age", "friends")]
# 각 클러스터별로 연령 평균 구하기
aggregate(data = teens, age ~ cluster, mean)
interests_z
# 각 클러스터별로 연령 평균 구하기
aggregate(data = teens, age ~ cluster, mean)
# 각 클러스터별로 여성의 비율 구하기
aggregate(data = teens, female ~ cluster, mean)
# 각 클러스터별로 친구 수 구하기
aggregate(data = teens, friends ~ cluster, mean)
aggregate(data = teens, soccer ~ cluster, mean)
sapply(interests, max)
teen_clusters
teen_clusters$size
teen_clusters$centers
teen_clusters
teen_clusters$centers
t(teen_clusters$centers)
lapply(t(teen_clusters$centers), sort)
as.data.frame(lapply(t(teen_clusters$centers), sort))
t(teen_clusters$centers)
sapply(t(teen_clusters$centers), sort, decreasing=T)
sapply(t(teen_clusters$centers), sort(decreasing=T))
sapply(t(teen_clusters$centers), sort, decreasing=T)
lapply(t(teen_clusters$centers), sort, decreasing=T))
lapply(t(teen_clusters$centers), sort, decreasing=T)
t(teen_clusters$centers)
teen_clusters$centers
teen_clusters$centers[1,]
sort(teen_clusters$centers[1,])
sort(teen_clusters$centers[1,], decreasing=T)
ob <- t(teen_clusters$centers)
names(ob)
rownames(ob)
df <- NULL
df <- NULL
ob <- t(teen_clusters$centers)
for(i in 1:ncol(ob)){
vec <- ob[,i]
names(vec) <- rownames(ob)
vec <- sort(vec, decreasing=T)
c_vec <- names(vec)
df <- cbind(df, c_vec)
}
df
lapply(teen_clusters$center, order)
sapply(teen_clusters$center, order)
tapply(teen_clusters$center, order)
teen_clusters$centers
t(teen_clusters$centers)
lapply(t(teen_clusters$centers), order)
order(c(21, 31, 512, 31))
teen_clusters$centers[1.]
teen_clusters$centers[1,]
bc <- names(teen_clusters$centers[1,])
class(bc)
bc[order(teens_clusters$centers[1,])]
bc[order(teen_clusters$centers[1,])]
df
lapply(ob)
lapply(ob, order)
teen_clusters$centers[,1]
teen_clusters$centers[1,]
order(teen_clusters$centers[1,])
order(teen_clusters$centers[1,])
mat <- NULL
for(i in 1:nrow(teen_clusters$centers)){
mat <- cbind(mat, names(teen_clusters$centers[i,])[order(teen_clusters$centers[1,])])
}
mat
mat <- cbind(mat, names(teen_clusters$centers[i,])[order(teen_clusters$centers[i,])])
mat <- NULL
for(i in 1:nrow(teen_clusters$centers)){
mat <- cbind(mat, names(teen_clusters$centers[i,])[order(teen_clusters$centers[i,])])
}
mat
apply(teen_clusters, 1, names, order)
apply(teen_clusters, 1, names)
apply(teen_clusters$centers, 1, names)
apply(names(teen_clusters$centers), 1, order)
apply(teen_clusters$centers, 1, order)
apply(teen_clusters$centers, 1, function(x) names(x)[order(x)])
#
# 사실 KNN은 학습이라고 할 만한 절차가 없다.
# 새로운 데이터가 생기면, 기존 데이터에서 이웃들을 뽑아 새로데이터 털를 분류한다.
#
# KNN을 모델로 별도로 구축하지 않는다는 뜻으로 게이른 모델이라고 부른다.
# 또는 Instance-based Learning이라고도 한다.
#
# Instance-based Learning 반의어 : model-based learning (모델을 구축함)
#
#
order(c(4, 3, 2, 1))
#
# 사실 KNN은 학습이라고 할 만한 절차가 없다.
# 새로운 데이터가 생기면, 기존 데이터에서 이웃들을 뽑아 새로데이터 털를 분류한다.
#
# KNN을 모델로 별도로 구축하지 않는다는 뜻으로 게이른 모델이라고 부른다.
# 또는 Instance-based Learning이라고도 한다.
#
# Instance-based Learning 반의어 : model-based learning (모델을 구축함)
#
#
-order(c(4, 3, 2, 1))
#
# 사실 KNN은 학습이라고 할 만한 절차가 없다.
# 새로운 데이터가 생기면, 기존 데이터에서 이웃들을 뽑아 새로데이터 털를 분류한다.
#
# KNN을 모델로 별도로 구축하지 않는다는 뜻으로 게이른 모델이라고 부른다.
# 또는 Instance-based Learning이라고도 한다.
#
# Instance-based Learning 반의어 : model-based learning (모델을 구축함)
#
#
num <- c(4, 3, 2, 1)
names(num) <- c("four", "three", "two", "1")
names(num)[order(num)]
function(mat, row, a, b){
x <- mat[row, 2]
y <- mat[row, 3]
return (a-x)^2 + (b-y)^2
}
knn_distance <- function(mat, row, a, b){
x <- mat[row, 2]
y <- mat[row, 3]
return (a-x)^2 + (b-y)^2
}
something <- data.frame(재료 <- c("포도", "껍질 콩", "견과", "오렌지"),
단맛 <- c(8, 3, 3, 7),
아삭한맛 <- c(5, 7, 6, 3),
토마토와의거리 <- c(NA, NA, NA, NA))
something
something <- as.data.frame(재료 <- c("포도", "껍질 콩", "견과", "오렌지"),
단맛 <- c(8, 3, 3, 7),
아삭한맛 <- c(5, 7, 6, 3),
토마토와의거리 <- c(NA, NA, NA, NA))
something <- as.data.frame(c("포도", "껍질 콩", "견과", "오렌지"),
c(8, 3, 3, 7),
c(5, 7, 6, 3),
c(NA, NA, NA, NA))
something
knn_distance <- function(mat, row, a, b){
for(i in 1:nrow(mat)){
ret <- c()
x <- mat[row, 2]
y <- mat[row, 3]
ret <- c(ret, (a-x)^2 + (b-y)^2)
}
return(ret)
}
test_matrix <- NULL
재료 <- c("포도", "껍질 콩", "견과", "오렌지")
단맛 <- c(8, 3, 3, 7)
아삭한맛 <- c(5, 7, 6, 3)
음식종류 <- c("과일", "채소", "단백질", "과일")
test_matrix<-cbind(test_matrix, 재료)
test_matrix<-cbind(test_matrix, 단맛)
test_matrix<-cbind(test_matrix, 아삭한맛)
test_matrix<-cbind(test_matrix, 음식종류)
test_matrix
knn_distance <- function(mat, row, a, b){
for(i in 1:nrow(mat)){
ret <- c()
x <- as.numeric(mat[row, 2])
y <- as.numeric(mat[row, 3])
ret <- c(ret, (a-x)^2 + (b-y)^2)
}
return(ret)
}
knn_distance <- function(mat, a, b){
for(i in 1:nrow(mat)){
ret <- c()
x <- as.numeric(mat[row, 2])
y <- as.numeric(mat[row, 3])
ret <- c(ret, (a-x)^2 + (b-y)^2)
}
return(ret)
}
knn_distance(test_matrix, 0, 0)
knn_distance <- function(mat, a, b){
for(i in 1:nrow(mat)){
ret <- c()
x <- as.numeric(mat[i, 2])
y <- as.numeric(mat[i, 3])
ret <- c(ret, (a-x)^2 + (b-y)^2)
}
return(ret)
}
knn_distance(test_matrix, 0, 0)
nrow(test_matrix)
knn_distance <- function(mat, a, b){
ret <- c()
for(i in 1:nrow(mat)){
x <- as.numeric(mat[i, 2])
y <- as.numeric(mat[i, 3])
ret <- c(ret, (a-x)^2 + (b-y)^2)
}
return(ret)
}
knn_distance(test_matrix, 0, 0)
knn_distance <- function(mat, a, b){
ret <- c()
for(i in 1:nrow(mat)){
x <- as.numeric(mat[i, 2])
y <- as.numeric(mat[i, 3])
ret <- c(ret, sqrt((a-x)^2 + (b-y)^2))
}
return(ret)
}
knn_distance(test_matrix, 0, 0)
knn_distance <- function(mat, a, b){
sqrt((mat[1] - a)^2 + (mat[2] - b)^2)
}
knn_distance(test_matrix, 0, 0)
test_matrix[2] <- as.numeric(test_matrix[2])
test_matrix[3] <- as.numeric(test_matrix[3])
test_matrix
class(test_matrix)
test_df <- as.matrix(test.matrix)
test_df <- as.matrix(test_matrix)
test_matrix[2] <- as.numeric(test_matrix[2])
test_matrix[3] <- as.numeric(test_matrix[3])
test_matrix
test_df
test_df[2] <- as.numeric(test_matrix[2])
test_df[3] <- as.numeric(test_matrix[3])
test_df
knn_distance <- function(x, y){
sqrt((mat[1] - a)^2 + (mat[2] - b)^2)
}
a <- matrix(c(8, 5, 3, 7, 3, 6, 7, 3), 4, 2, byrow=T)
knn_distance <- function(x, y){
sqrt((mat[1] - a)^2 + (mat[2] - b)^2)
}
a
knn_distance(0, 0)
a
knn_distance <- function(x, y){
sqrt((a[1] - x)^2 + (a[2] - y)^2)
}
knn_distance(0, 0)
knn_distance <- function(x, y){
sqrt((a[,1] - x)^2 + (a[,2] - y)^2)
}
knn_distance(0, 0)
knn_distance(6, 4)
